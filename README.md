# -How-is-the-network-connected
# 网络是怎么连接的
## 第一章 浏览器生成消息

## 第二章 用电信号传输TCP/IP 数据 --探索协议栈和网卡
### 2.1 创建套接字
* 2.1.1 协议栈的内部结构<br/>
  **协议栈**是指网络中各层协议的总和，本质是**操作系统内部的网络控制软件**，也叫**协议驱动**或者**TCP/IP驱动**，其形象的反映了一个网络中文件传输的过程：由上层协议到底层协议，再由底层协议到上层协议。<br/>
  协议栈内部主要分为两层：**TCP协议和UDP协议**作为一层，其下面还有**IP协议**作为另一层；<br/>
  整个系统分层结构为:<br/>
  **应用程序**<br/>
  **Socket库(DNS解析器、socket组件、connect组件、write组件、read组件、close组件)**<br/>
  **协议栈(上层的TCP协议和UDP协议，下层的IP协议(ICMP、ARP协议))**<br/>
  **网卡驱动程序(控制网卡)**<br/>
  **网卡(负责对网线中的信号执行发送和接收的操作)**<br/>
  **收发数据的时候，上层会将收发数据的工作委派给下层**<br/>
  **ICMP**:用于告知网络包传送过程中产生的错误以及各种控制消息；<br/>
  **ARP**:用于根据IP地址查询相应的以太网MAC地址；<br/>
  
* 2.1.2 套接字的实体
  在协议栈的内部有一块**用于存放控制消息的内存空间**，其中控制消息包括，**源IP地址、源端口、目的IP地址、目的端口、连接状态、是否已经收到了响应、发送数据后经过了多长时间**等；<br/>
  所以我们通常把这个**用于存放控制信息的内存空间称为套接字的实体，协议栈会根据这些控制信息进行下一步操作**，这也就是套接字的作用；<br/>
  套接字其实是可以通过命令行的方式来查看的，可以通过**netstat -an -p TCP**命令来查看，-a表示**不仅显示正在通信状态(ESTABLISHED状态)的套接字，还显示处于尚未开始通信状态(LISTENING状态)的套接字**，-n表示**显示IP地址和端口号**<br/>
  ![](https://github.com/JS-Even-JS/-How-is-the-network-connected/blob/master/images/socket.png)
  图中的每一行就是一个socket套接字<br/>
  tcp46       0      0  *.8080                 *.*                    LISTEN     <br/>
  ip地址为*号*表示远程ip地址和本地ip地址都未确定，说明通信还没有开始，处于监听状态，在等待客户端的连接，并且是在8080端口上等待客户端连接；<br/>
  tcp4       0      0  127.0.0.1.8080         127.0.0.1.65213        ESTABLISHED <br/>
  这个是**服务器端**的socket <br/>
  tcp4       0      0  127.0.0.1.65213        127.0.0.1.8080         ESTABLISHED <br/>
  这个是**客户端**的socket <br/>
  因为一个socket是由客户端ip和端口、服务器端ip和端口共同组成，所以这也可以解释**为什么多个客户端可以连接到同一台服务器上的同一个端口上了**<br/>
  
* 2.1.3 调用socket组件时的创建操作
  应用程序和协议栈直接隔着一个Socket库，所以**应用程序必须通过Socket库来向协议栈发出一系列的委托请求**<br/>
  ① **创建套接字阶段**,应用程序首先会调用Socket库中的**socket组件**申请创建套接字，然后**协议栈根据应用程序的申请执行套接字的创建操作**,协议栈会向**内存管理模块**提出申请，请求划分一块内存空间出来，用于**存放创建的套接字**，其实这个给套接字的空间就是**用于给套接字存放控制信息的**，套接字创建好之后，**会给套接字写入一些初始的状态控制信息**；<br/>
  创建好的套接字会**存放于协议栈中**，确切的说是存放在了**协议栈中的TCP模块中**，因为只有TCP协议才会使用套接字进行通信；<br/>
  socket组件会返回创建好的socket的**描述符**，即 **<描述符> = socket(<使用IPv4>,<使用TCP协议>)**,返回的socket描述符会传递给应用程序，应用程序委托协议栈发送数据的时候**需要提供这个socket描述符**<br/>
  服务器程序启动的时候也会创建套接字，只不过这个套接字是处于LISTEN监听状态，在等待客户端的连接；<br/>
  
### 2.2 连接服务器
* 2.2.1 调用connect组件的连接操作<br/>
  所谓**连接**，就是**通信的双方互相交换控制信息**。套接字刚创建好之后，里面并没有存放任何数据，也不知道通信的对象是谁，但是浏览器从输入的url地址中可以指定通信对象的ip地址和端口号，所以**需要把服务器的ip地址和端口号告知协议栈**，应用程序委托协议栈发送数据的时候，协议栈才知道该给谁发送数据。在进行连接的过程中，由于**需要进行收发数据的操作，所以也会向内存管理模块申请一片内存空间，即所谓的缓冲区，用来临时存放要收发的数据**<br/>

* 2.2.2 负责保存控制信息的头部<br/>
  控制信息主要分类两类：<br/>
  a. **网络包的头部(IP头部和TCP头部)控制信息** <br/>
  b. **socket中保存的控制信息** <br/>

* 2.2.3 connect连接的过程<br/>
  ② 应用程序会调用Socket库中的connect组件进行连接操作，即:<br/>
  **connect(<描述符>,<服务器IP地址和端口号>)** <br/>
  传递的服务器IP地址和端口号会通过协议栈传递给其中的TCP协议模块，TCP模块会创建TCP头部并对头部控制信息进行初始化，比如**填入源端口和目的端口号、将控制位SYN设置为1，同时将计算出来的随机的初始包序号告诉服务器即seq=x**，客户端TCP头部创建好之后，TCP模块就会将信息传递给客户端的IP模块，IP模块会添加上IP头部，IP头部会添加上**源IP地址和目的IP地址**，IP模块将网络包发送出去后，会被服务器的IP模块接收到，并且**会将接收到的头部信息传递给服务器的TCP模块**，服务器的TCP模块会根据接收到的TCP头部控制信息中记录的目的端口号**找到处于监听状态的服务器套接字，并向套接字中写入相应的信息，并将状态改为正在连接**；<br/>
  服务器的TCP模块接收到来自客户端的网络包之后，还需要**对客户端的网络包进行确认**，服务器的TCP模块也会创建一个TCP头部，也会填入源端口和目的端口以及设置上对应的控制位，将SYN置为1，同时还需要**将ACK确认位置为1，以及服务器端随机生成的初始包序号告诉客户端即seq=y**，表示对客户端网络包的确认，服务器已经接收到了客户端发送过来的网络包；<br/>
  客户端TCP模块接收到了来自服务器TCP模块的确认后，就会检查其收到的TCP头部控制信息，如果SYN为1，表示**服务器同意连接，即连接成功**，这时，客户端协议栈**会向客户端socket中写入服务器的IP地址和端口号信息，同时将状态改为连接完毕(ESTABLISHED)状态**<br/>
  客户端还需要对服务器发送过来的网络包进行确认，告诉服务器刚才的响应包已经收到，服务器收到客户端的确认之后就**会向服务端的socket中写入客户端的IP地址和端口号信息，同时将状态改为连接完毕(ESTABLISHED)状态**<br/>
  
### 2.3 收发数据
* 2.3.1 将HTTP请求消息交给协议栈<br/>
  ③ 应用程序会调用Socket库中的write组件进行发送数据操作，即:<br/>
   **write(要发送的数据)**<br/>
   应用程序会将数据通过Socket库中的write组件交给协议栈，但是**协议栈并不会将数据立即发送出去，而是将接收到的数据保存在连接时创建的数据缓冲区中**。因为如果一接到数据就将数据发送出去，就会发送大量的小包到网络中，导致网络效率低，因此**需要将数据累积到一定程度再发出去**。其判断依据为:<br/>
   a. **每个网络包所能容纳的数据长度**，即**MSS(除去头部之后，一个网络包所能容纳的TCP数据的最大长度)**(), 一个TCP的头部最小为20字节，最大为60字节，所以TCP头部的长度是不固定的，而**一个网络是有最大长度限制的，为1500字节**<br/>
   b. **等待时间**，如果每次发送数据都要等到缓存区的数据达到MSS的长度再发送出去，就会导致等待的时间过长而产生发送延迟，为此**协议栈内部有一个计时器，当达到指定的时间后就会把网络包发送出去**<br/>
   
* 2.3.2 **对较大数据进行拆分**<br/>
  通常HTTP请求消息以便都不会很长，一个网络包就能装下，但是如果应用程序一次性提交了很长的数据，比如**在博客上发表了一篇很长的文章**，那么这时缓冲区中的数据长度就会超过MSS的长度，这个时候就不需要再等待了后面的数据了，**缓冲区中的数据就会以MSS的长度为单位进行拆分，拆分出来的每块数据都会被放进单独的网络包中** <br/>

* 2.3.3 **使用ACK号确认网络包已经收到**<br/>
  在TCP三次握手进行连接的过程中，第一次和第二次握手都会发送一个**SYN=1的同步标志位，表示进行连接操作，其目的是为了告诉对方自己这边包的初始序号，所以还会带上seq=x(客户端初始包序号)和seq=y(服务器端初始包序号)**, 在实际通信过程中，包的初始序号是**采用随机算法计算出来的一个随机数**，之所以要随机产生是为了防止黑客的攻击。所以可以简单理解为:**第一次握手是为了告诉服务器，客户端的初始化包序号为seq=x;第二次握手是为了告诉客户端，服务器的初始化序号为seq=y**<br/>
  **由于初始值在传输的过程中有可能会丢失**，所以当服务器接收到客户端发送过来的初始包序号后，**还需要返回一个ACK确认号进行确认**，客户端通过返回的ACK确认号就能判断服务器是否已经接收到了客户端发送过来初始化包序号;**确认号的计算就是通过包的序号seq与接收到包的长度之和计算得来，而数据包的长度可以通过整个数据包长度减去头部的长度计算而来**;<br/>
  第二次握手的时候，服务器向客户端发送了SYN=1的同步标志位已经告诉客户端，服务器端的初始包序号seq=y，同时对客户端进行了确认返回了一个确认号ack=x+1,同时将确认标志位也置为1，表示确认号有效;<br/>
  所以之所以还需要第三次握手，那是因为服务器在第二次握手的时候发送过来的初始化包序号seq=y，**有可能在传输过程中丢失，客户端必须对这个seq=y进行确认，让服务器知道，客户端已经成功接收到了服务器发送过来的初始包序号，因为确认号需要通过初始包序号计算出来，服务器可以通过检查确认号来判断客户端有没有成功接收到服务器的初始包序号**<br/>
  这就是所谓的超时重传机制，如果没有收到接收方的确认号就会重新发送，有了这一机制我们就不需要在其他地方对错误进行补救了，因此，**网卡、集线器、路由器都没有这种错误补偿机制，一旦发生错误则直接将数据包丢弃**<br/>

* 2.3.4 **根据网络包的平均往返时间动态调整ACK号的等待时间**<br/>
  如果ACK号的等待时间过短，当**网络繁忙的时候**,ACK号的返回会变慢，这个时候由于等待时间过短，ACK号还没返回就会进行重传，导致原本拥堵的网络更加拥堵了;<br/>
  如果ACK号的等待时间过长，那么包的重传就会出现很大的延迟，本该重传确因时间未到而不能重传，从而导致网络变慢;<br/>
  **所以TCP会根据当前网络速率，持续测量ACK号的返回时间，然后求取平均值的方式来动态改变ACK的等待时间**，当网络变慢的时候，则会相应的延长ACK的等待时间;当网络变快的时候，则会相应缩短ACK的等待时间;<br/>

* 2.3.5 **使用窗口有效管理ACK号**<br/>
  如果发送方发送一次数据后，就**傻傻等待接收方返回ACK确认**，那么**在等待ACK确认号的这段时间就白白浪费了**，所以为了有效利用起等待接收方法返回ACK返回的这段时间，发送方应该继续发送数据，但是这样有可能出现**发送方发送数据过快，而接收方来不及处理数据，导致接收方缓存区数据溢出**的情况，所以为了避免这种情况，**接收方需要告诉发送方，接收方最多还能接收多少数据，然后让发送方根据这个值对发送操作进行控制**，这就是所谓的**滑动窗口协议**;<br/>
  **当接收方将数据传递给应用程序进行处理的时候**，就会导致缓冲区剩余容量增加，这个时候我们就需要更新窗口大小并通知发送方,这是**更新窗口大小的最佳时机**;<br/>
  实际上当接收方接收到数据后就应该向发送方返回ACK号确认，但是如果接收到数据后就立即返回ACK确认，那么就会导致**返回ACK确认和更新窗口大小需要分别发送一个单独的数据包，这样会造成网络拥堵**，所以TCP采用了**延迟ACK确认的机制**，接收方在接收到数据后并不会立即进行返回ACK确认，而是有一个**200ms的延迟**，这段时间内有可能会有**新的数据要确认，返回最后一个ACK即可**，也有可能**应用程序处理了部分数据导致窗口大小更新，这个时候会同时将ACK的确认和窗口的更新放在同一个包里**，从而减少包的数量，避免网络拥堵;<br/>

* 2.3.6 **接收HTTP响应消息**<br/>
  浏览器在委托协议栈发送请求消息之后，就会立刻调用Socket库中的read组件来尝试从数据缓冲区中读取数据并传递给应用程序，但是此时由于**请求刚刚发出，响应可能还没有返回，所以需要等待一段时间才会有响应数据，此时从缓冲区中读取数据并传递给应用程序的工作就好暂时挂起**，接收数据的时候，**接收方协议栈会首先检查TCP头部序号，判断数据是否有遗漏，如果没有遗漏那么会返回一个ACK号，然后将已经确认的数据缓存到缓冲区中，并将这些数据按顺序连接起来还原出原始数据并将其交给应用程序**<br/>
  判断数据
  
